<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>uvgRTP: uvgrtp::media_stream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">uvgRTP
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>uvgrtp</b></li><li class="navelem"><a class="el" href="classuvgrtp_1_1media__stream.html">media_stream</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classuvgrtp_1_1media__stream-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">uvgrtp::media_stream Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0950a91bd645cbf842d8218ae4171aed"><td class="memItemLeft" align="right" valign="top">rtp_error_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvgrtp_1_1media__stream.html#a0950a91bd645cbf842d8218ae4171aed">add_srtp_ctx</a> (uint8_t *key, uint8_t *salt)</td></tr>
<tr class="memdesc:a0950a91bd645cbf842d8218ae4171aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add keying information for user-managed SRTP session.  <a href="classuvgrtp_1_1media__stream.html#a0950a91bd645cbf842d8218ae4171aed">More...</a><br /></td></tr>
<tr class="separator:a0950a91bd645cbf842d8218ae4171aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b7507d5b2c76bef74c9bceec07ba18"><td class="memItemLeft" align="right" valign="top">rtp_error_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvgrtp_1_1media__stream.html#ab2b7507d5b2c76bef74c9bceec07ba18">push_frame</a> (uint8_t *data, size_t data_len, int flags)</td></tr>
<tr class="memdesc:ab2b7507d5b2c76bef74c9bceec07ba18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to remote participant with a custom timestamp.  <a href="classuvgrtp_1_1media__stream.html#ab2b7507d5b2c76bef74c9bceec07ba18">More...</a><br /></td></tr>
<tr class="separator:ab2b7507d5b2c76bef74c9bceec07ba18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e79cf2f90f81a90ae9c22e0c1fb01e"><td class="memItemLeft" align="right" valign="top">rtp_error_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvgrtp_1_1media__stream.html#ab2e79cf2f90f81a90ae9c22e0c1fb01e">push_frame</a> (std::unique_ptr&lt; uint8_t[]&gt; data, size_t data_len, int flags)</td></tr>
<tr class="memdesc:ab2e79cf2f90f81a90ae9c22e0c1fb01e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to remote participant with a custom timestamp.  <a href="classuvgrtp_1_1media__stream.html#ab2e79cf2f90f81a90ae9c22e0c1fb01e">More...</a><br /></td></tr>
<tr class="separator:ab2e79cf2f90f81a90ae9c22e0c1fb01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18975c5463df0664f1fd8ab495248dcc"><td class="memItemLeft" align="right" valign="top">rtp_error_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvgrtp_1_1media__stream.html#a18975c5463df0664f1fd8ab495248dcc">push_frame</a> (uint8_t *data, size_t data_len, uint32_t ts, int flags)</td></tr>
<tr class="memdesc:a18975c5463df0664f1fd8ab495248dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to remote participant with a custom timestamp.  <a href="classuvgrtp_1_1media__stream.html#a18975c5463df0664f1fd8ab495248dcc">More...</a><br /></td></tr>
<tr class="separator:a18975c5463df0664f1fd8ab495248dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85fed1e02b97326d3b794551f0677e2b"><td class="memItemLeft" align="right" valign="top">rtp_error_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvgrtp_1_1media__stream.html#a85fed1e02b97326d3b794551f0677e2b">push_frame</a> (std::unique_ptr&lt; uint8_t[]&gt; data, size_t data_len, uint32_t ts, int flags)</td></tr>
<tr class="memdesc:a85fed1e02b97326d3b794551f0677e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to remote participant with a custom timestamp.  <a href="classuvgrtp_1_1media__stream.html#a85fed1e02b97326d3b794551f0677e2b">More...</a><br /></td></tr>
<tr class="separator:a85fed1e02b97326d3b794551f0677e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fe9e8d9b67e25f103a78a25417149f"><td class="memItemLeft" align="right" valign="top">uvgrtp::frame::rtp_frame *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvgrtp_1_1media__stream.html#ae2fe9e8d9b67e25f103a78a25417149f">pull_frame</a> ()</td></tr>
<tr class="memdesc:ae2fe9e8d9b67e25f103a78a25417149f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poll a frame indefinitely from the media stream object.  <a href="classuvgrtp_1_1media__stream.html#ae2fe9e8d9b67e25f103a78a25417149f">More...</a><br /></td></tr>
<tr class="separator:ae2fe9e8d9b67e25f103a78a25417149f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441263e19be4383223884fde8838f736"><td class="memItemLeft" align="right" valign="top">uvgrtp::frame::rtp_frame *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvgrtp_1_1media__stream.html#a441263e19be4383223884fde8838f736">pull_frame</a> (size_t timeout)</td></tr>
<tr class="memdesc:a441263e19be4383223884fde8838f736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poll a frame for a specified time from the media stream object.  <a href="classuvgrtp_1_1media__stream.html#a441263e19be4383223884fde8838f736">More...</a><br /></td></tr>
<tr class="separator:a441263e19be4383223884fde8838f736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a558b23866976e52c5903996544a27"><td class="memItemLeft" align="right" valign="top">rtp_error_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvgrtp_1_1media__stream.html#a74a558b23866976e52c5903996544a27">install_receive_hook</a> (void *arg, void(*hook)(void *, uvgrtp::frame::rtp_frame *))</td></tr>
<tr class="memdesc:a74a558b23866976e52c5903996544a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous way of getting frames.  <a href="classuvgrtp_1_1media__stream.html#a74a558b23866976e52c5903996544a27">More...</a><br /></td></tr>
<tr class="separator:a74a558b23866976e52c5903996544a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf1cde9cb8c4e4af3160ce24c4288a5"><td class="memItemLeft" align="right" valign="top">rtp_error_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvgrtp_1_1media__stream.html#addf1cde9cb8c4e4af3160ce24c4288a5">configure_ctx</a> (int flag, ssize_t value)</td></tr>
<tr class="memdesc:addf1cde9cb8c4e4af3160ce24c4288a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the media stream, see <a class="el" href="util_8hh.html#aa98d9238629e33567e73af0d239e587f" title="RTP context configuration flags.">RTP_CTX_CONFIGURATION_FLAGS</a> for more details.  <a href="classuvgrtp_1_1media__stream.html#addf1cde9cb8c4e4af3160ce24c4288a5">More...</a><br /></td></tr>
<tr class="separator:addf1cde9cb8c4e4af3160ce24c4288a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1134ff0271ad54bf1e07feed422118c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuvgrtp_1_1rtcp.html">uvgrtp::rtcp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvgrtp_1_1media__stream.html#a1134ff0271ad54bf1e07feed422118c2">get_rtcp</a> ()</td></tr>
<tr class="memdesc:a1134ff0271ad54bf1e07feed422118c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to the RTCP object of the media stream.  <a href="classuvgrtp_1_1media__stream.html#a1134ff0271ad54bf1e07feed422118c2">More...</a><br /></td></tr>
<tr class="separator:a1134ff0271ad54bf1e07feed422118c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0950a91bd645cbf842d8218ae4171aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0950a91bd645cbf842d8218ae4171aed">&#9670;&nbsp;</a></span>add_srtp_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtp_error_t uvgrtp::media_stream::add_srtp_ctx </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>salt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add keying information for user-managed SRTP session. </p>
<p>For user-managed SRTP session, the media stream is not started until SRTP key has been added and all calls to <a class="el" href="classuvgrtp_1_1media__stream.html#ab2b7507d5b2c76bef74c9bceec07ba18" title="Send data to remote participant with a custom timestamp.">push_frame()</a> will fail</p>
<p>Currently uvgRTP only supports key length of 16 bytes (128 bits) and salt length of 14 bytes (112 bits).</p>
<p>If the key or salt is longer, it is implicitly truncated to correct length and if the key or salt is shorter, a memory violation may occur</p>
<p>Notice that if user-managed SRTP has been enabled during media stream creation, this function must be called before anything else. All calls to other functions will fail with <a class="el" href="util_8hh.html#aa6dc3f3578923d1afc40045e4cbe387ba32d67254c4da35568e7007ec3825f98a" title="Object has not been initialized.">RTP_NOT_INITIALIZED</a> until the SRTP context has been specified</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>128-bit long key </td></tr>
    <tr><td class="paramname">salt</td><td>112-bit long salt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RTP error code</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RTP_OK</td><td>On success </td></tr>
    <tr><td class="paramname">RTP_INVALID_VALUE</td><td>If key or salt is invalid </td></tr>
    <tr><td class="paramname">RTP_NOT_SUPPORTED</td><td>If user-managed SRTP was not specified in create_stream() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addf1cde9cb8c4e4af3160ce24c4288a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf1cde9cb8c4e4af3160ce24c4288a5">&#9670;&nbsp;</a></span>configure_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtp_error_t uvgrtp::media_stream::configure_ctx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the media stream, see <a class="el" href="util_8hh.html#aa98d9238629e33567e73af0d239e587f" title="RTP context configuration flags.">RTP_CTX_CONFIGURATION_FLAGS</a> for more details. </p>
<dl class="section return"><dt>Returns</dt><dd>RTP error code</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RTP_OK</td><td>On success </td></tr>
    <tr><td class="paramname">RTP_INVALID_VALUE</td><td>If the provided value is not valid for a given configuration flag </td></tr>
    <tr><td class="paramname">RTP_INVALID_VALUE</td><td>If the provided configuration flag is not supported </td></tr>
    <tr><td class="paramname">RTP_GENERIC_ERROR</td><td>If setsockopt(2) failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1134ff0271ad54bf1e07feed422118c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1134ff0271ad54bf1e07feed422118c2">&#9670;&nbsp;</a></span>get_rtcp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuvgrtp_1_1rtcp.html">uvgrtp::rtcp</a>* uvgrtp::media_stream::get_rtcp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to the RTCP object of the media stream. </p>
<p>This object is used to control all RTCP-related functionality and RTCP documentation can be found from <a class="el" href="classuvgrtp_1_1rtcp.html">uvgrtp::rtcp</a></p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to RTCP object</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uvgrtp::rtcp*</td><td>If RTCP has been enabled (RCE_RTCP has been given to <a class="el" href="classuvgrtp_1_1session.html#a71aad1226214b1b0b1ba60a46c048ab2" title="Create a bidirectional media stream for an RTP session.">uvgrtp::session::create_stream()</a>) </td></tr>
    <tr><td class="paramname">nullptr</td><td>If RTCP has not been enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74a558b23866976e52c5903996544a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a558b23866976e52c5903996544a27">&#9670;&nbsp;</a></span>install_receive_hook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtp_error_t uvgrtp::media_stream::install_receive_hook </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *, uvgrtp::frame::rtp_frame *)&#160;</td>
          <td class="paramname"><em>hook</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous way of getting frames. </p>
<p>Receive hook is an alternative to polling frames using <a class="el" href="classuvgrtp_1_1media__stream.html#ae2fe9e8d9b67e25f103a78a25417149f" title="Poll a frame indefinitely from the media stream object.">uvgrtp::media_stream::pull_frame()</a>. Instead of application asking from uvgRTP if there are any new frames available, uvgRTP will notify the application when a frame has been received</p>
<p>The hook should not be used for media processing as it will block the receiver from reading more frames. Instead, it should only be used as an interface between uvgRTP and the calling application where the frame hand-off happens.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Optional argument that is passed to the hook when it is called, can be set to nullptr </td></tr>
    <tr><td class="paramname">hook</td><td>Function pointer to the receive hook that uvgRTP should call</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RTP error code</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RTP_OK</td><td>On success </td></tr>
    <tr><td class="paramname">RTP_INVALID_VALUE</td><td>If hook is nullptr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2fe9e8d9b67e25f103a78a25417149f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2fe9e8d9b67e25f103a78a25417149f">&#9670;&nbsp;</a></span>pull_frame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uvgrtp::frame::rtp_frame* uvgrtp::media_stream::pull_frame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Poll a frame indefinitely from the media stream object. </p>
<dl class="section return"><dt>Returns</dt><dd>RTP frame</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uvgrtp::frame::rtp_frame*</td><td>On success </td></tr>
    <tr><td class="paramname">nullptr</td><td>If an unrecoverable error happened </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a441263e19be4383223884fde8838f736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441263e19be4383223884fde8838f736">&#9670;&nbsp;</a></span>pull_frame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uvgrtp::frame::rtp_frame* uvgrtp::media_stream::pull_frame </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Poll a frame for a specified time from the media stream object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>How long is a frame waited, in milliseconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RTP frame</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uvgrtp::frame::rtp_frame*</td><td>On success </td></tr>
    <tr><td class="paramname">nullptr</td><td>If a frame was not received within the specified time limit </td></tr>
    <tr><td class="paramname">nullptr</td><td>If an unrecoverable error happened </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2e79cf2f90f81a90ae9c22e0c1fb01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e79cf2f90f81a90ae9c22e0c1fb01e">&#9670;&nbsp;</a></span>push_frame() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtp_error_t uvgrtp::media_stream::push_frame </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; uint8_t[]&gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data to remote participant with a custom timestamp. </p>
<p>If so specified either by the selected media format and/or given <a class="el" href="util_8hh.html#a15b2d6364db6065a482c99827f4bd2af" title="RTP context enable flags.">RTP_CTX_ENABLE_FLAGS</a>, uvgRTP fragments the input data into RTP packets of 1500 bytes, or to any other size defined by the application using <a class="el" href="util_8hh.html#aa98d9238629e33567e73af0d239e587fa7667fb72b42a2c11991b4879619f9f83">RCC_MTU_SIZE</a></p>
<p>The frame is automatically reconstructed by the receiver if all fragments have been received successfully.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Smart pointer to data the that should be sent </td></tr>
    <tr><td class="paramname">data_len</td><td>Length of data </td></tr>
    <tr><td class="paramname">flags</td><td>Optional flags, see <a class="el" href="util_8hh.html#af03a75996471fc531742cd640c7caf2d" title="These flags are given to uvgrtp::media_stream::push_frame() and they can be OR&#39;ed together.">RTP_FLAGS</a> for more details</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RTP error code</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RTP_OK</td><td>On success </td></tr>
    <tr><td class="paramname">RTP_INVALID_VALUE</td><td>If one of the parameters are invalid </td></tr>
    <tr><td class="paramname">RTP_MEMORY_ERROR</td><td>If the data chunk is too large to be processed </td></tr>
    <tr><td class="paramname">RTP_SEND_ERROR</td><td>If uvgRTP failed to send the data to remote </td></tr>
    <tr><td class="paramname">RTP_GENERIC_ERROR</td><td>If an unspecified error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85fed1e02b97326d3b794551f0677e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85fed1e02b97326d3b794551f0677e2b">&#9670;&nbsp;</a></span>push_frame() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtp_error_t uvgrtp::media_stream::push_frame </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; uint8_t[]&gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data to remote participant with a custom timestamp. </p>
<p>If so specified either by the selected media format and/or given <a class="el" href="util_8hh.html#a15b2d6364db6065a482c99827f4bd2af" title="RTP context enable flags.">RTP_CTX_ENABLE_FLAGS</a>, uvgRTP fragments the input data into RTP packets of 1500 bytes, or to any other size defined by the application using <a class="el" href="util_8hh.html#aa98d9238629e33567e73af0d239e587fa7667fb72b42a2c11991b4879619f9f83">RCC_MTU_SIZE</a></p>
<p>The frame is automatically reconstructed by the receiver if all fragments have been received successfully.</p>
<p>If application so wishes, it may override uvgRTP's own timestamp calculations and provide timestamping information for the stream itself. This requires that the application provides a sensible value for the ts parameter. If RTCP has been enabled, <a class="el" href="classuvgrtp_1_1rtcp.html#a5d0d06f9b4b7779d96d8d60938627316" title="Provide timestamping information for RTCP.">uvgrtp::rtcp::set_ts_info()</a> should have been called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Smart pointer to data the that should be sent </td></tr>
    <tr><td class="paramname">data_len</td><td>Length of data </td></tr>
    <tr><td class="paramname">ts</td><td>32-bit timestamp value for the data </td></tr>
    <tr><td class="paramname">flags</td><td>Optional flags, see <a class="el" href="util_8hh.html#af03a75996471fc531742cd640c7caf2d" title="These flags are given to uvgrtp::media_stream::push_frame() and they can be OR&#39;ed together.">RTP_FLAGS</a> for more details</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RTP error code</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RTP_OK</td><td>On success </td></tr>
    <tr><td class="paramname">RTP_INVALID_VALUE</td><td>If one of the parameters are invalid </td></tr>
    <tr><td class="paramname">RTP_MEMORY_ERROR</td><td>If the data chunk is too large to be processed </td></tr>
    <tr><td class="paramname">RTP_SEND_ERROR</td><td>If uvgRTP failed to send the data to remote </td></tr>
    <tr><td class="paramname">RTP_GENERIC_ERROR</td><td>If an unspecified error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2b7507d5b2c76bef74c9bceec07ba18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b7507d5b2c76bef74c9bceec07ba18">&#9670;&nbsp;</a></span>push_frame() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtp_error_t uvgrtp::media_stream::push_frame </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data to remote participant with a custom timestamp. </p>
<p>If so specified either by the selected media format and/or given <a class="el" href="util_8hh.html#a15b2d6364db6065a482c99827f4bd2af" title="RTP context enable flags.">RTP_CTX_ENABLE_FLAGS</a>, uvgRTP fragments the input data into RTP packets of 1500 bytes, or to any other size defined by the application using <a class="el" href="util_8hh.html#aa98d9238629e33567e73af0d239e587fa7667fb72b42a2c11991b4879619f9f83">RCC_MTU_SIZE</a></p>
<p>The frame is automatically reconstructed by the receiver if all fragments have been received successfully.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to data the that should be sent </td></tr>
    <tr><td class="paramname">data_len</td><td>Length of data </td></tr>
    <tr><td class="paramname">flags</td><td>Optional flags, see <a class="el" href="util_8hh.html#af03a75996471fc531742cd640c7caf2d" title="These flags are given to uvgrtp::media_stream::push_frame() and they can be OR&#39;ed together.">RTP_FLAGS</a> for more details</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RTP error code</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RTP_OK</td><td>On success </td></tr>
    <tr><td class="paramname">RTP_INVALID_VALUE</td><td>If one of the parameters are invalid </td></tr>
    <tr><td class="paramname">RTP_MEMORY_ERROR</td><td>If the data chunk is too large to be processed </td></tr>
    <tr><td class="paramname">RTP_SEND_ERROR</td><td>If uvgRTP failed to send the data to remote </td></tr>
    <tr><td class="paramname">RTP_GENERIC_ERROR</td><td>If an unspecified error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18975c5463df0664f1fd8ab495248dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18975c5463df0664f1fd8ab495248dcc">&#9670;&nbsp;</a></span>push_frame() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtp_error_t uvgrtp::media_stream::push_frame </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data to remote participant with a custom timestamp. </p>
<p>If so specified either by the selected media format and/or given <a class="el" href="util_8hh.html#a15b2d6364db6065a482c99827f4bd2af" title="RTP context enable flags.">RTP_CTX_ENABLE_FLAGS</a>, uvgRTP fragments the input data into RTP packets of 1500 bytes, or to any other size defined by the application using <a class="el" href="util_8hh.html#aa98d9238629e33567e73af0d239e587fa7667fb72b42a2c11991b4879619f9f83">RCC_MTU_SIZE</a></p>
<p>The frame is automatically reconstructed by the receiver if all fragments have been received successfully.</p>
<p>If application so wishes, it may override uvgRTP's own timestamp calculations and provide timestamping information for the stream itself. This requires that the application provides a sensible value for the ts parameter. If RTCP has been enabled, <a class="el" href="classuvgrtp_1_1rtcp.html#a5d0d06f9b4b7779d96d8d60938627316" title="Provide timestamping information for RTCP.">uvgrtp::rtcp::set_ts_info()</a> should have been called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to data the that should be sent </td></tr>
    <tr><td class="paramname">data_len</td><td>Length of data </td></tr>
    <tr><td class="paramname">ts</td><td>32-bit timestamp value for the data </td></tr>
    <tr><td class="paramname">flags</td><td>Optional flags, see <a class="el" href="util_8hh.html#af03a75996471fc531742cd640c7caf2d" title="These flags are given to uvgrtp::media_stream::push_frame() and they can be OR&#39;ed together.">RTP_FLAGS</a> for more details</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RTP error code</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RTP_OK</td><td>On success </td></tr>
    <tr><td class="paramname">RTP_INVALID_VALUE</td><td>If one of the parameters are invalid </td></tr>
    <tr><td class="paramname">RTP_MEMORY_ERROR</td><td>If the data chunk is too large to be processed </td></tr>
    <tr><td class="paramname">RTP_SEND_ERROR</td><td>If uvgRTP failed to send the data to remote </td></tr>
    <tr><td class="paramname">RTP_GENERIC_ERROR</td><td>If an unspecified error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="media__stream_8hh_source.html">media_stream.hh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
